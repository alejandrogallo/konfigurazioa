* Introduction

This is a typed configuration, allowing for:
- [X] Basic types
- [X] Optional types
- [X] Lists (typed or untyped)
- [X] Union types
- [ ] Callables (lambdas etc)
- [ ] Python expressions
- [ ] Guards
- [ ] User defined types

* Configuration file concept

A program will define some configuration settings.  Every setting can
be defined globally or within a namespace. For instance the following
configuratoin

#+begin_src yaml
port: 80
base: index.html
proxy: None

my-namespace:
  port: 90
  base: main.html
  proxy: 121.12.41.2
#+end_src

defines ~port~, ~base~ and ~proxy~ settings.  However, these settings are
overriden within the namespace ~my-namespace~.

The defining configuration in the main program for this case would be
#+begin_src yaml
port:
  default: 80
  type: int
  doc: |
    Port for the main application to listen to.
base:
  default: index.html
  type: str
  doc: Static file to serve in the root.
proxy:
  default: None
  type: Optional[str]
  doc: Proxy to reroute your main application.
#+end_src

** Python configuration

A pythonic version of the configuration is also allowed

#+begin_src python
c.port = 80
c.base = "index.html"
c.proxy = None

with c.namespace("my-namespace") as p:
    p.port = 90
    p.base = "base.html"
    p.proxy = "121.12.41.2"
#+end_src

* Implementation

The main objectives of this library should be:
- [ ] correctly parsing the configuration file.
- [ ] checking that the values of the settings check against the defined
  type schema provided by the library.
- [ ] for the library user, be sure of getting the correct type
  of a value provided in the configuration, if an error occurs,
  throw well-defined and well-documented exceptions.
  
** Types

The main structure for the types is given by a class with a 
~match~ and a ~parse~ function.

#+begin_src python :noweb yes :tangle (k-types-test-file) :exports none :results none
import konfigurazioa.types as kt


#+end_src

#+begin_src python :noweb yes :tangle (k-types-file) :exports code :results none
import functools
from typing import ( Any, List, TypeVar, Generic, Type, Union, Optional
                   , Callable, Tuple
                   )
import re

_T = TypeVar("_T")

class T(Generic[_T]):
    name = "T"

    def match(self: "T", v: Any) -> bool:
        try:
            self.parse(v)
        except ValueError:
            return False
        else:
            return True

    def parse(self: "T", v: Any) -> _T:
        ...

class BasicTypeWrapper(T[_T]):
    caster = None  # type: Optional[Callable[[Any], _T]]

    def match(self: "BasicTypeWrapper", v: Any) -> bool:
        try:
            self.parse(v)
        except ValueError:
            return False
        else:
            return True

    def parse(self: "BasicTypeWrapper", v: Any) -> _T:
        try:
            if self.caster is None:
                raise Exception("caster must be set")
            else:
                return self.caster(v)
        except ValueError:
            raise ValueError("Invalid value for type {} ({})"
                             .format(self.name, v))
#+end_src

Now we can define the basic python types as wrapped types.

#+begin_src python :noweb yes :tangle (k-types-file) :exports code :results none

class Int(BasicTypeWrapper[int]):
    caster = int
    name = "Int"

class Float(BasicTypeWrapper[float]):
    caster = float
    name = "Float"

class Bool(T[bool]):
    name = "Bool"
    def parse(self: "Bool", v: Any) -> bool:
        if isinstance(v, bool):
            return v
        else:
            if v in ["true", "True"]:
                return True
            if v in ["false", "False"]:
                return False
        raise ValueError("Invalid value for type {} ({})"
                         .format(self.name, v))

class String(BasicTypeWrapper[str]):
    caster = str
    name = "String"

# for higher kinded types
_K = TypeVar("_K", bound="T")
_L = TypeVar("_L", bound="T")

class _Optional(T[Optional[_K]]):

    wrap_type = None  # type: Optional[_K]

    def parse(self: "_Optional[_K]", v: Any) -> Optional[_K]:
        if v is None or v == "None":
            return None
        else:
            if self.wrap_type is None:
                raise Exception("Optional class needs a wrap_type")
            else:
                return self.wrap_type.parse(v)


class _List(T[List[_K]]):

    wrap_type = None  # type: Optional[_K]

    def parse(self: "_List[_K]", v: Any) -> List[_K]:
        if isinstance(v, list):
            l = v
        else:
            l = re.findall(r"[^,\[\]()]+", str(v))
            if not l:
                raise Exception("Invalid list: {}".format(v))

        if self.wrap_type is None:
            raise Exception("List class needs a wrap_type")
        else:
            return [self.wrap_type.parse(e) for e in l]


class _Union(T[Union[_K, _L]]):

    wrap_types = None  # type: Optional[Tuple[_K, _L]]

    def parse(self: "_Union[_K, _L]", v: Any) -> Union[_K, _L]:
        if self.wrap_types is None:
            raise TypeError("Union need wrap_types")
        for i in range(2):
            try:
                t = self.wrap_types[i]
                return t.parse(v)
            except ValueError:
                pass
        raise ValueError("Invalid value for type {} ({})"
                         .format(self.name, v))


def string_to_union(name: str) -> Optional[_Union[_K, _L]]:
    m = re.match(r"Union\[([^\[\]]+)\s*,\s*([^\[\]]+)\s*\]", name)
    if not m:
        return None
    fst = string_to_type(m.group(1))
    snd = string_to_type(m.group(2))
    class __A(_Union):
        pass
    a = __A()
    a.wrap_types = (fst, snd)
    a.name = name
    return a


def string_to_list(name: str) -> Optional[_List[_K]]:
    m = re.match(r"List\[([^\[\]]+)\]", name)
    if not m:
        return None
    t = string_to_type(m.group(1))
    class __A(_List):
        pass
    a = __A()
    a.wrap_type = t
    a.name = name
    return a


def string_to_opt(name: str) -> Optional[_Optional[_K]]:
    m = re.match(r"Optional\[([^\[\]]+)\]", name)
    if not m:
        return None
    t = string_to_type(m.group(1))
    class __A(_Optional):
        pass
    a = __A()
    a.wrap_type = t
    a.name = name
    return a


TYPES = [ lambda x: re.match(Int.name, x) and Int()
        , lambda x: re.match(Float.name, x) and Float()
        , lambda x: re.match(String.name, x) and String()
        , lambda x: re.match(Bool.name, x) and Bool()
        , string_to_opt
        , string_to_list
        , string_to_union
        ]  # List[Callable[[str], T]]


def string_to_type(name: str, types=TYPES) -> T:
    for t in types:
        _t = t(name)
        if _t:
            return _t
    raise TypeError("Type {} not recognised".format(name))

#+end_src

#+begin_src python :noweb yes :tangle (k-types-test-file) :exports none :results none

def test_int() -> None:
    Int = kt.string_to_type("Int")
    assert isinstance(Int, kt.T)
    assert Int.parse("5") == 5
    assert Int.parse(5) == 5
    assert Int.parse(5.4) == 5


def test_float() -> None:
    Float = kt.string_to_type("Float")
    assert isinstance(Float, kt.T)
    assert Float.parse("5") == 5.0
    assert Float.parse(5) == 5.0
    assert Float.parse(5.4) == 5.4


def test_opt() -> None:
    OptInt = kt.string_to_opt("Optional[Int]")
    assert OptInt
    assert OptInt.parse(None) == None
    assert OptInt.parse("None") == None
    assert OptInt.parse(4.4) == 4
    OptFloat = kt.string_to_opt("Optional[Float]")
    assert OptFloat
    assert OptFloat.parse(None) == None
    assert OptFloat.parse("None") == None
    assert OptFloat.parse("4.4") == 4.4
    assert OptInt.parse(5.12) == 5


def test_list_int() -> None:
    ListInt = kt.string_to_list("List[Int]")
    assert ListInt
    assert isinstance(ListInt, kt.T)
    assert ListInt.parse("1,2,3,4") == [1,2,3,4]

    ListString = kt.string_to_list("List[String]")
    assert isinstance(ListString, kt.T)
    assert ListString.parse("1,2,3,4") == "1,2,3,4".split(",")
    assert ListString.parse("hello world,2,3,4") == "hello world,2,3,4".split(",")

def test_union_int_bool() -> None:
    EitherIntOrBool = kt.string_to_union("Union[Int, Bool]")
    assert EitherIntOrBool
    for p, v in [ ("True", True)
                , ("true", True)
                , ("False", False)
                , ("false", False)
                , (1, 1)
                , ("12", 12)
                ]:
        assert EitherIntOrBool.parse(p) is v


#+end_src
